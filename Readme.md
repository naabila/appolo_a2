### ১. PostgreSQL কী?

PostgreSQL হলো একটি শক্তিশালী, ওপেন-সোর্স অবজেক্ট-রিলেশনাল ডাটাবেস ম্যানেজমেন্ট সিস্টেম (ORDBMS)। এটি তার **নির্ভরযোগ্যতা (reliability)**, **বৈশিষ্ট্যের দৃঢ়তা (robust feature set)**, **SQL স্ট্যান্ডার্ডের প্রতি কঠোর আনুগত্য (strong adherence to SQL standards)** এবং **চমৎকার কার্যকারিতার (performance)** জন্য বিশ্বজুড়ে পরিচিত।

এর **এক্সটেনসিবিলিটি (extensibility)** একটি মূল বৈশিষ্ট্য, যার অর্থ ডেভেলপাররা এতে কাস্টম ডেটা টাইপ, অ্যাগ্রিগেট ফাংশন তৈরি করতে পারে এবং এমনকি বিভিন্ন প্রোগ্রামিং ল্যাঙ্গুয়েজে (যেমন PL/pgSQL, PL/Python, PL/Perl) কোড লিখতে পারে। এটি ছোট ব্যক্তিগত প্রকল্প থেকে শুরু করে বৃহৎ এন্টারপ্রাইজ সিস্টেম পর্যন্ত বিস্তৃত অ্যাপ্লিকেশনের জন্য একটি বহুমুখী এবং নির্ভরযোগ্য পছন্দ।

### ২. PostgreSQL-এ ডাটাবেস স্কিমার উদ্দেশ্য কী?

PostgreSQL-এ একটি ডাটাবেস স্কিমা একটি ডাটাবেসের মধ্যে একটি **লজিক্যাল নামস্থান (logical namespace)** হিসাবে কাজ করে। এটি টেবিল, ভিউ, ফাংশন, ইনডেক্স, সিকোয়েন্স এবং অন্যান্য ডাটাবেস অবজেক্টের একটি নামযুক্ত সংগ্রহ। স্কিমা ব্যবহারের প্রধান উদ্দেশ্যগুলো হলো:

* **সংগঠন (Organization):** সম্পর্কিত ডাটাবেস অবজেক্টগুলোকে একসাথে গ্রুপ করা, যা একটি বড় এবং জটিল ডাটাবেসকে আরও সহজে পরিচালনা করতে সাহায্য করে।
* **নামকরণের দ্বন্দ্ব (Naming Conflicts) প্রতিরোধ:** বিভিন্ন স্কিমায় একই নামের অবজেক্ট থাকতে পারে কোনো দ্বন্দ্ব ছাড়াই। উদাহরণস্বরূপ, `hr_schema.employees` এবং `payroll_schema.employees` দুটি ভিন্ন টেবিল হতে পারে, যদিও তাদের নাম একই।
* **নিরাপত্তা (Security):** স্কিমা স্তরে ব্যবহারকারীদের অ্যাক্সেস নিয়ন্ত্রণ করা যায়, যা ডেটার নিরাপত্তা বাড়ায়। নির্দিষ্ট স্কিমায় শুধুমাত্র অনুমোদিত ব্যবহারকারীরা অ্যাক্সেস করতে পারে।
* **মাল্টি-টেন্যান্সি (Multi-tenancy):** একই ডাটাবেসের মধ্যে একাধিক অ্যাপ্লিকেশন বা ক্লায়েন্টকে তাদের অবজেক্টগুলো পৃথক রেখে কাজ করার অনুমতি দেওয়া।

**টেবিল উদাহরণ:**

| schema_name | table_name |
| :---------- | :--------- |
| `public`    | `users`    |
| `hr`        | `employees`|
| `sales`     | `products` |

### ৩. PostgreSQL-এ Primary Key এবং Foreign Key ধারণাগুলো ব্যাখ্যা করুন।

এগুলো রিলেশনাল ডাটাবেসে ডেটার অখণ্ডতা (data integrity) এবং টেবিলের মধ্যে সম্পর্ক (relationships) বজায় রাখার জন্য মৌলিক ধারণা:

* **Primary Key (প্রাথমিক কী):** একটি প্রাথমিক কী হলো একটি টেবিলের একটি কলাম (বা কলামের সংমিশ্রণ) যা সেই টেবিলের প্রতিটি সারিকে **অনন্যভাবে (uniquely)** চিহ্নিত করে। এর মূল বৈশিষ্ট্যগুলো হলো:
    * **অনন্যতা (Uniqueness):** একই টেবিলের দুটি সারির একই প্রাথমিক কী মান থাকতে পারে না।
    * **নন-নালিবিলিটি (Non-Nullability):** একটি প্রাথমিক কী কলামে `NULL` (খালি) মান থাকতে পারে না।
    * এটি একটি টেবিলের মধ্যে রেকর্ড শনাক্তকরণের প্রধান মাধ্যম হিসেবে কাজ করে।

    **উদাহরণ টেবিল (`Customers`):**
    | `customer_id` (PK) | `customer_name` | `email`           |
    | :----------------- | :-------------- | :---------------- |
    | `C101`             | `আসিফ আহমেদ`    | `asif@example.com`|
    | `C102`             | `নুসরাত জাহান`   | `nusrat@example.com`|

* **Foreign Key (ফরেন কী):** একটি ফরেন কী হলো একটি কলাম (বা কলামের সেট) যা একটি টেবিলের মধ্যে থাকে এবং **অন্য একটি টেবিলের প্রাথমিক কী-কে নির্দেশ করে**। এর প্রধান ভূমিকাগুলো হলো:
    * **সম্পর্ক স্থাপন:** এটি দুটি টেবিলের মধ্যে একটি লিঙ্ক তৈরি করে, যা তাদের মধ্যে সম্পর্ক (যেমন, একজন গ্রাহকের একাধিক অর্ডার থাকতে পারে) নির্দেশ করে।
    * **রেফারেনশিয়াল ইন্টিগ্রিটি (Referential Integrity) প্রয়োগ:** এটি নিশ্চিত করে যে টেবিলের মধ্যে সম্পর্কগুলো সুসংগত থাকে। উদাহরণস্বরূপ, যদি একটি ফরেন কী এর মাধ্যমে একজন গ্রাহকের সাথে কোনো অর্ডার সংযুক্ত থাকে, তাহলে আপনি সেই গ্রাহককে মুছে ফেলতে পারবেন না যতক্ষণ না সেই অর্ডারটি মুছে ফেলা হয় বা অন্য গ্রাহকের সাথে যুক্ত করা হয়।

    **উদাহরণ টেবিল (`Orders`):**
    | `order_id` (PK) | `customer_id` (FK) | `order_date` | `total_amount` |
    | :-------------- | :----------------- | :----------- | :------------- |
    | `O001`          | `C101`             | `2024-05-20` | `1500.00`      |
    | `O002`          | `C102`             | `2024-05-21` | `2300.50`      |
    | `O003`          | `C101`             | `2024-05-22` | `800.00`       |

    এখানে, `Orders` টেবিলের `customer_id` কলামটি `Customers` টেবিলের `customer_id` কলামের একটি ফরেন কী।

### ৪. `VARCHAR` এবং `CHAR` ডেটা প্রকারের মধ্যে পার্থক্য কী?

`VARCHAR` এবং `CHAR` উভয়ই ক্যারেক্টার স্ট্রিং সংরক্ষণ করতে ব্যবহৃত হয়, তবে তারা স্টোরেজ এবং দৈর্ঘ্যের ক্ষেত্রে ভিন্নভাবে কাজ করে:

* **`CHAR(n)`:** এই ডেটা প্রকারটি একটি **নির্দিষ্ট-দৈর্ঘ্যের (fixed-length)** স্ট্রিং সংরক্ষণ করে।
    * আপনি যদি একটি কলাম `CHAR(10)` হিসাবে ঘোষণা করেন এবং "hello" সন্নিবেশ করেন, তবে এটি এখনও 10 বাইট স্টোরেজ দখল করবে, বাকি 5 বাইট স্পেস দিয়ে পূরণ করে।
    * এটি দ্রুততর হতে পারে যখন ডেটার দৈর্ঘ্য সর্বদা `n` হবে বলে আপনি নিশ্চিত হন।

* **`VARCHAR(n)`:** এই ডেটা প্রকারটি একটি **পরিবর্তনশীল-দৈর্ঘ্যের (variable-length)** স্ট্রিং সংরক্ষণ করে।
    * আপনি যদি একটি কলাম `VARCHAR(10)` হিসাবে ঘোষণা করেন এবং "hello" সন্নিবেশ করেন, তবে এটি কেবল সেই 5টি অক্ষরের জন্য প্রয়োজনীয় স্থান ব্যবহার করবে, সাথে সামান্য অতিরিক্ত স্থান (সাধারণত দৈর্ঘ্যের তথ্যের জন্য 1 বাইট)।
    * ডেটার দৈর্ঘ্য পরিবর্তিত হয় এমন ক্ষেত্রে এটি সাধারণত আরও নমনীয় এবং স্থান-দক্ষ (space-efficient)।

**উদাহরণ:**
যদি আপনি `CHAR(5)` কলামে 'Hi' সংরক্ষণ করেন, তাহলে এটি 'Hi   ' (3টি অতিরিক্ত স্থান) হিসাবে সংরক্ষণ হবে।
যদি আপনি `VARCHAR(5)` কলামে 'Hi' সংরক্ষণ করেন, তাহলে এটি কেবল 'Hi' হিসাবে সংরক্ষণ হবে (2টি বাইট + ওভারহেড)।

আধুনিক PostgreSQL ডেভেলপমেন্টে, `VARCHAR` সাধারণত বেশি পছন্দ করা হয়, যদি না নির্দিষ্ট দৈর্ঘ্যের স্টোরেজের জন্য খুব বিশেষ কোনো কারণ থাকে (যেমন, খুব নির্দিষ্ট পরিস্থিতিতে পারফরম্যান্স অপ্টিমাইজেশন)।

### ৫. `SELECT` স্টেটমেন্টে `WHERE` ক্লজের উদ্দেশ্য কী?

`WHERE` ক্লজ `SELECT` স্টেটমেন্টের একটি মৌলিক উপাদান যা সারিগুলোকে **ফিল্টার (filter)** করতে ব্যবহৃত হয়। এটি আপনাকে এক বা একাধিক শর্ত নির্দিষ্ট করার অনুমতি দেয় যা একটি সারিকে ফলাফলে অন্তর্ভুক্ত করার জন্য পূরণ করতে হবে। সহজ কথায়, এটি ডাটাবেসকে বলে দেয় যে আপনি কোন সারিগুলোতে আগ্রহী।

**সিনট্যাক্স:**
```sql
SELECT column1, column2, ...
FROM table_name
WHERE condition;